# Enterprise GitHub Functional Intelligence Planner Agent

# Gemini via API (NO Vertex AI)
 
import os
from dotenv import load_dotenv

import requests

import google.generativeai as genai

# Load environment variables from .env file
load_dotenv()
 
 
class PlannerAgent:
 
    def __init__(self):
 
        # Gemini API setup

        api_key = os.getenv("GEMINI_API_KEY")

        if not api_key:

            raise Exception("GEMINI_API_KEY not set")
 
        genai.configure(api_key=api_key)
 
        self.model = genai.GenerativeModel("gemini-2.5-flash")
 
        # Optional GitHub token (recommended)

        self.github_token = os.getenv("GITHUB_TOKEN")
 
    # ------------------------------------------------

    # GitHub Data Fetching

    # ------------------------------------------------
 
    def fetch_repo_data(self, repo_url):
 
        repo = repo_url.replace("https://github.com/", "")

        headers = {}
 
        if self.github_token:

            headers["Authorization"] = f"Bearer {self.github_token}"
 
        # Repo metadata

        repo_api = f"https://api.github.com/repos/{repo}"

        repo_data = requests.get(repo_api, headers=headers).json()
 
        # Issues

        issues_api = f"https://api.github.com/repos/{repo}/issues?state=open"

        issues = requests.get(issues_api, headers=headers).json()
 
        # Pull Requests

        pr_api = f"https://api.github.com/repos/{repo}/pulls?state=open"

        prs = requests.get(pr_api, headers=headers).json()
 
        return {

            "repo": repo_data,

            "issues": issues[:20],   # limit for token efficiency

            "prs": prs[:20]

        }
 
    # ------------------------------------------------

    # Gemini Planning + Functional Intelligence

    # ------------------------------------------------
 
    def analyze(self, repo_url):
 
        github_data = self.fetch_repo_data(repo_url)
 
        prompt = f"""

You are an Enterprise GitHub Functional Intelligence Agent.
 
Analyze the following repository data and identify:
 
1. Security risks or missing security practices in codebase

2. Architecture improvement opportunities in codebase

3. Performance risks or scalability gaps in codebase

4. Missing enterprise features or functionality in codebase

5. Developer efficiency improvement suggestions in codebase
 
Repository metadata:

{github_data['repo']}
 
Open Issues:

{github_data['issues']}
 
Open Pull Requests:

{github_data['prs']}
 
Provide structured enterprise analysis with clear recommendations.

"""
 
        response = self.model.generate_content(prompt)
 
        return response.text

    # ------------------------------------------------
    # GitHub Issue Creation
    # ------------------------------------------------

    def create_issue_with_analysis(self, repo_url, analysis_result):
        """
        Create a GitHub issue with the analysis findings and recommendations
        """
        if not self.github_token:
            raise Exception("GitHub token is required to create issues. Please set GITHUB_TOKEN environment variable.")
        
        repo = repo_url.replace("https://github.com/", "")
        print(f"Debug: Creating issue for repository: {repo}")  # Debug log
        
        # Format the analysis for GitHub issue
        issue_title = "üîç Functional Intelligent Agent"
        
        issue_body = f"""# üöÄ Functional Intelligent Agent

**Repository:** `{repo}`
**Analysis Date:** {self._get_current_date()}
**Generated by:** Functional Intelligent Agent

---

{analysis_result}

---

## üìã Next Steps

- [ ] Review security recommendations and implement fixes
- [ ] Assess architecture improvements for scalability
- [ ] Address performance bottlenecks identified
- [ ] Implement missing enterprise features
- [ ] Apply developer efficiency improvements

**Note:** This analysis was generated automatically. Please review and prioritize recommendations based on your specific needs.
"""
        
        headers = {
            "Authorization": f"Bearer {self.github_token}",
            "Accept": "application/vnd.github.v3+json",
            "Content-Type": "application/json"
        }
        
        issue_data = {
            "title": issue_title,
            "body": issue_body,
            "labels": ["analysis", "enhancement", "enterprise"]
        }
        
        issues_api = f"https://api.github.com/repos/{repo}/issues"
        print(f"Debug: Making request to: {issues_api}")  # Debug log
        
        try:
            response = requests.post(issues_api, headers=headers, json=issue_data)
            print(f"Debug: Response status: {response.status_code}")  # Debug log
            print(f"Debug: Response content: {response.text[:500]}...")  # Debug log
            
            if response.status_code == 201:
                issue_data = response.json()
                return {
                    "success": True,
                    "issue_url": issue_data["html_url"],
                    "issue_number": issue_data["number"],
                    "message": f"Successfully created issue #{issue_data['number']}"
                }
            else:
                try:
                    error_detail = response.json().get('message', 'Unknown error')
                except:
                    error_detail = response.text
                return {
                    "success": False,
                    "error": f"Failed to create issue: {response.status_code} - {error_detail}"
                }
                
        except Exception as e:
            print(f"Debug: Exception in create_issue_with_analysis: {str(e)}")  # Debug log
            return {
                "success": False,
                "error": f"Error creating issue: {str(e)}"
            }
    
    def _get_current_date(self):
        from datetime import datetime
        return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

    def analyze_and_create_issue(self, repo_url):
        """
        Analyze repository and optionally create an issue with the findings
        """
        # First, perform the analysis
        analysis_result = self.analyze(repo_url)
        
        return {
            "analysis": analysis_result,
            "repo_url": repo_url
        }

 